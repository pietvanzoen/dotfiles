#!/usr/bin/env ruby
require "#{Dir.home}/lib/pnote_lib"

def main()
  pnote = PNote.new()
  cmd = ARGV[0]
  case cmd
  when 'view', 'v'
    pnote.view_cmd
  when 'add', 'a'
    pnote.add_cmd
  when 'edit', 'e'
    pnote.edit_cmd
  when 'remove'
    pnote.remove_cmd
  when 'help', 'h', nil
    Print.help(ARGV[1])
  else
    puts "Unknown command '#{cmd}'"
    puts "See 'pnote help' for available commands"
    exit(1)
  end
end


class PNote
  PNOTE_DIR = ENV['PNOTE_DIR'] || "#{Dir.home}/.pnote"
  TEMP_CONTENT_FILE = "#{PNOTE_DIR}/PNOTE_TEMPCONENT.md"
  PNOTE_DB = "#{PNOTE_DIR}/pnote.yml"

  def initialize
    FileUtils.mkdir_p(PNOTE_DIR) unless Dir.exists?(PNOTE_DIR)

    @repo = NotesRepo.new(PNOTE_DB)
  end

  def view_cmd
    assert_max_arg_count 2
    find = ARGV[1]
    if find.nil? then
      Print.books(@repo.find_all)
      return
    end

    notes = @repo.find_all({'book' => find})
    return Print.notes(notes) unless notes.empty?

    note = @repo.find({'id' => find})
    return Print.note(note) unless note.nil?

    puts "Could not find book or note with id '#{find}'."
    exit(1)
  end

  def add_cmd
    assert_max_arg_count 2
    cmd = ARGV[0]
    book = ARGV[1]
    Util.assert(book, "Book name is required. See 'pnote help #{cmd}'.")
    note_data = edit_note({'book' => book})
    n = @repo.create!({'book' => note_data['book'], 'content' => note_data['content'] })
    puts "Saved new note:"
    Print.note(n)
  end

  def edit_cmd
    assert_max_arg_count 2
    note = get_note_from_args
    note_data = edit_note({'book' => note.book, 'content' => note.content})
    @repo.update!(note.id, note_data)
    puts "Edited note: "
    Print.note(note)
  end

  def remove_cmd
    assert_max_arg_count 2
    note = get_note_from_args
    Print.note(note)
    print "==> Confirm delete the above note: [yn] "
    ans = STDIN.gets.strip
    exit(0) unless ans == 'y'
    @repo.archive!({ 'id' => note.id })
  end

  def get_note_from_args
    cmd = ARGV[0]
    id = ARGV[1]
    Util.assert(id, "Note id is required. See 'pnote help #{cmd}'.")
    note = @repo.find({'id' => id})
    if note.nil? then
      puts "Could not find note with id #{id}."
      exit(1)
    end
    note
  end

  def edit_note(params)
    front_matter = {
      'book' => params.fetch('book')
    }
    content = params.fetch('content', '')
    template="#{front_matter.to_yaml}\n---\n#{content}"
    File.write(TEMP_CONTENT_FILE, template)
    system("#{ENV['EDITOR']}", TEMP_CONTENT_FILE)
    md = File.read(TEMP_CONTENT_FILE)
    data = {
      'book' => YAML.load(md).fetch('book', '').strip || front_matter['book'],
      'content' => md.split('---').last.strip
    }
    if data['content'].empty? then
      puts "Note content is required."
      exit(1)
    end
    data
  end

  def assert_max_arg_count(n)
    Util.assert(ARGV.count <= n, "Too many arguments. See 'pnote help #{ARGV[0]}' for help.")
  end
end

module Print
  def self.books(notes)
    bullet = '•'.blue
    puts "#{notes.count} notes:"
    notes.sort_by{|n| n.book }.group_by{|n| n.book }.each do |key, notes|
      count = "(#{notes.count})".yellow
      puts "#{bullet} #{key} #{count}"
    end
  end

  def self.notes(notes)
    puts "#{notes.count} notes:"
    notes.each_with_index do |note, index|
      id = ('%-5.4s' % "(#{note.id})").yellow
      puts " #{id} #{Util.truncate("#{note.content}", 160)}"
    end
  end

  def self.note(note)
    Util.assert(note, 'Could not find note.')
    bullet = '•'.blue
    puts "#{bullet} id:         #{note.id}"
    puts "#{bullet} book:       #{note.book}"
    puts "#{bullet} created at: #{note.created_at}"
    puts "#{bullet} updated at: #{note.updated_at}"
    puts
    puts "------ content -------"
    puts note.content
    puts "----------------------"
  end

  def self.help(cmd=nil)
    case cmd
    when 'a', 'add'
      msg = "USAGE: dnote add <book>
Add a new note. $EDITOR will open for input."
    when 'e', 'edit'
      msg = "USAGE: dnote edit <note id>
Edit a note."
    when 'remove'
      msg = "USAGE: dnote remove <note id>
Remove a note."
    when 'view', 'v'
      msg = "USAGE: dnote view [<book|note id>]
List books, notes, or view a single note."
    else
      msg="USAGE: dnote [command]

Available commands:
  add, a      Add a note
  edit, e     Edit a note
  help        Help about any command
  remove      Remove a note or a book
  view, v     List books, notes or view a content

Data is stored in ~/.pnote/ by default. You can override this by setting $pnote_dir in your environment."
      end

    puts msg.strip
  end
end

module Util
  def self.truncate(str, length)
    return str unless str.length > length
    str = str.lines.first.strip
    more = "[---more---]".yellow
    return "#{str[0, length]} #{more}"
  end

  def self.assert(val, msg)
  return unless !val
  STDERR.puts msg
  exit(1)
  end
end

class String
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end
  def red
    colorize(31)
  end
  def green
    colorize(32)
  end
  def yellow
    colorize(33)
  end
  def blue
    colorize(34)
  end
  def pink
    colorize(35)
  end
  def light_blue
    colorize(36)
  end
end

if __FILE__ == $0 then
  main
end
