#!/usr/bin/env ruby
require "#{Dir.home}/lib/pnote_lib"

def main()
  pnote = PNote.new()
  cmd = ARGV[0]
  case cmd
  when 'view', 'v'
    pnote.view_cmd
  when 'add', 'a'
    pnote.add_cmd
  when 'edit', 'e'
    pnote.edit_cmd
  when 'remove'
    pnote.remove_cmd
  when 'help', 'h', nil
    Print.help(ARGV[1])
  else
    puts "Unknown command '#{cmd}'"
    puts "See 'pnote help' for available commands"
    exit(1)
  end
end


class PNote
  PNOTE_DIR = ENV['PNOTE_DIR'] || "#{Dir.home}/.pnote"
  TEMP_CONTENT_FILE = "#{PNOTE_DIR}/PNOTE_TEMPCONENT"
  PNOTE_DB = "#{PNOTE_DIR}/pnote.yml"

  def initialize
    FileUtils.mkdir_p(PNOTE_DIR) unless Dir.exists?(PNOTE_DIR)

    @repo = NotesRepo.new(PNOTE_DB)
  end

  def view_cmd
    book = ARGV[1]
    note_index = ARGV[2]
    if not note_index.nil? then
      Print.note(@repo.find({'book' => book, 'note_index' => note_index.to_i}))
    elsif not book.nil? then
      Print.notes(@repo.find_all({'book' => book}))
    else
      Print.books(@repo.find_all)
    end
  end

  def add_cmd
    cmd = ARGV[0]
    book = ARGV[1]
    Util.assert(book, "Book name is required. See 'pnote help #{cmd}'.")
    content = (ARGV[2] || get_content_from_editor).strip
    if content.empty? then
      puts "Content empty. No note added."
      exit(1)
    end
    n = @repo.create!({'book' => book, 'content' => content })
    puts "Saved new note:"
    puts n.content
  end

  def edit_cmd
    note = get_note_from_args
    content = get_content_from_editor note.content
    @repo.update!(note.id, { 'content' => content })
    puts "edited note '#{note_index}' in '#{book}': "
    puts content
  end

  def remove_cmd
    note = get_note_from_args
    Print.note(note)
    print "==> Confirm delete the above note: [yn] "
    ans = STDIN.gets.strip
    exit(0) unless ans == 'y'
    @repo.archive!(note.id)
  end

  def get_note_from_args
    cmd = ARGV[0]
    book = ARGV[1]
    note_index = ARGV[2]
    Util.assert(book, "Book name is required. See 'pnote help #{cmd}'.")
    Util.assert(note_index, "Note index is required. See 'pnote help #{cmd}'.")
    @repo.find({'book' => book, 'note_index' => note_index.to_i})
  end

  def get_content_from_editor(populate='')
    File.write(TEMP_CONTENT_FILE, populate)
    system("#{ENV['EDITOR']}", TEMP_CONTENT_FILE)
    return File.read(TEMP_CONTENT_FILE).strip
  end
end

module Print
  def self.books(notes)
    bullet = '•'.blue
    notes.sort_by{|n| n.book }.group_by{|n| n.book }.each do |key, notes|
      count = "(#{notes.count})".yellow
      puts "#{bullet} #{key} #{count}"
    end
  end

  def self.notes(notes)
    puts "#{notes.count} notes:"
    notes.each_with_index do |note, index|
      id = "(#{index})".yellow
      puts " #{id} #{Util.truncate("#{note.content}", 100)}"
    end
  end

  def self.note(note)
    Util.assert(note, 'Could not find note.')
    bullet = '•'.blue
    puts "#{bullet} id: #{note.id}"
    puts "#{bullet} created at: #{note.created_at}"
    puts "#{bullet} updated at: #{note.updated_at}"
    puts
    puts "------ content -------"
    puts note.content
    puts "----------------------"
  end

  def self.help(cmd=nil)
    case cmd
    when 'a', 'add'
      msg = "usage: dnote add <book> [<content>]
add a new note. if no content is given your $editor will open for input."
    when 'e', 'edit'
      msg = "usage: dnote edit <book> <note index>
edit a note."
    when 'remove'
      msg = "usage: dnote remove <book> <note index>
remove a note."
    when 'view', 'v'
      msg = "usage: dnote view [<book>] [<note index>]
list books, notes, or view a single note."
    else
      msg="usage: dnote [command]

available commands:
  add, a      add a note
  edit, e     edit a note
  help        help about any command
  remove      remove a note or a book
  view, v     list books, notes or view a content

data is stored in ~/.pnote/ by default. you can override this by setting $pnote_dir in your environment."
      end

    puts msg.strip
  end
end

module Util
  def self.truncate(str, length)
    return str unless str.length > length
    str = str.lines.first.strip
    more = "[---more---]".yellow
    return "#{str[0, length]} #{more}"
  end

  def self.assert(val, msg)
  return unless !val
  STDERR.puts msg
  exit(1)
  end
end

class String
  def colorize(color_code)
    "\e[#{color_code}m#{self}\e[0m"
  end
  def red
    colorize(31)
  end
  def green
    colorize(32)
  end
  def yellow
    colorize(33)
  end
  def blue
    colorize(34)
  end
  def pink
    colorize(35)
  end
  def light_blue
    colorize(36)
  end
end

if __FILE__ == $0 then
  main
end
